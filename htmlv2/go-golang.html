<!DOCTYPE html>
<html lang="en">
<head>
    <title>Wiki - Go (Golang)</title>  
    <LINK REL=StyleSheet HREF="style.css" TYPE="text/css">  
    <meta charset="UTF-8">
    <meta name="description" content="Wiki Technical Documentation">
    <meta name="keywords" content="linux system administration,unix system administration,linux sysadmin,unix sysadmin,wiki linux, 
    linux technical documentation,sed,cut,awk,find,ssh,pts,tty,iptables,docker,sql,git,github,go,golang,go golang,ssl,openssl,network,
    linux network,network management,linux network management,vi text editor,vi how to quit,text editor,ide,linux ide,linux resources,bash,
    shellscript,bash shellscript,shell scripting,loop,bash loop,colors in bash,color in bash,bash color,bash colors">
    <meta name="author" content="Thomas Simon">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
<nav id="navbar">
        <header>Technical Documentation</header>
        <ul>
          <li><a href="index.html#Introduction" class="nav-link" >Introduction</a></li>
          <li><a href="index.html#Bash_and_Shellscript" class="nav-link">Bash and Shellscript</a></li>
          <li><a href="index.html#Linux_and_Unix_Tools" class="nav-link">Linux and Unix Tools</a></li>
          <li><a href="index.html#Vi_Basics" class="nav-link">Vi Basics</a></li>
          <li><a href="index.html#Useful_Commands" class="nav-link">Useful Commands</a></li>
          <li><a href="index.html#SSH,_PTS_and_TTY" class="nav-link">SSH, PTS and TTY</a></li>
          <li><a href="index.html#Iptables_and_Network_Management" class="nav-link">Iptables and Network Management</a></li>
          <li><a href="index.html#Common_SQL_Commands" class="nav-link">Common SQL Commands</a></li>
          <li><a href="index.html#SSL_Tips_and_Tricks" class="nav-link">SSL Tips and Tricks</a></li>
          <li><a href="index.html#Docker_Commands" class="nav-link">Docker Commands</a></li>
          <li><a href="index.html#Git_and_GitHub_Memo" class="nav-link">Git and GitHub Memo</a></li>
          <li><a href="index.html#Go_(Golang)" class="nav-link">Go (Golang)</a></li>
          <li><a href="index.html#LDAP_and_Open_LDAP_Management_and_Administration" class="nav-link">LDAP and Open LDAP Management and Administration</a></li>
          <li><a href="index.html#Useful_Resources" class="nav-link">Useful Resources</a></li>
        </ul>
      </nav>

<main id="main-doc">
<section class="main-section" id="">
    <header>Go (Golang)</header><hr>
    <article><p>This section's content is:
    <a href="#intro">Introduction</a>, <a href="#inst">Installation</a>, 
    <a href="#basics">Basic Commands</a>, <a href="#ssh">Installing over SSH</a>,
    <a href="#basic">Basic Concepts</a>, <a href="#rem">Remainder</a>, 
    <a href="#loop">Loop and Print </a>, <a href="#var">Variables and Constants</a>,
     <a href="#scope">Scopes and Wrappers</a>, <a href="#mem">Memory Addresses</a>.
    And soon, I hope, more to come. Otherwise, I'll be writting a page about Python...</p><hr>
    </article>
</section>
<section class="main-section" id="intro">
    <header>Introduction</header><hr>
    <article>
            <p>Compiled - Go 1.5 and above enable native cross compilation on a system i.e.: on a mac declare env vars like GOOS=linux GOARCH=amd64go build will then build an executable for a Linux OS on the host machine running OS X.<br>
                On Windows add export GOOS= export GOARCH export<br>
                Object Oriented<br>
                Native support for Multiple cores<br>
                Network oriented/friendly<br>
                Manages memory / Garbage collecting<br>
                Clean syntax as scripting lang / low level language<br>
                Multi OS very portable<br>
                Procedural language where procedures equals functions, stitched together into a whole program<br>
                Can do what node.js does server side<br>
                Semicolons automatically included and placed by the compiler / 2 statements on the same line equals a semicolon to differentiate them<br>
                Package Declaration 1st line:<br>
                "package main" where main refers to the folder containing the go program(s), code, application(s)
                Can be organized by folder for program types and purposes, i.e.: crypto, system, network, webapp etc…<br>
                Import on second line:<br>
                "import" enables us to import pre-existent code into the program: we can import procedures (functions) and whole other GO programs, import packages from standard and third parties libraries<br>
                fmt.Println where package is fmt and the function is print line as in Println Print just sequentially prints the content Println adds a new line to the standard output render<br>
                Packages catalogue in standard library (and more for third parties at http://godoc.org ) https://golang.org/pkg/#stdlib<br>
                Every procedures (functions) are explained and documented for each package<br>
                Replace PKG in URL with src to access the source code of a package<br>
                No Polution in Code<br>
                Package declaration:<br>
                Import statement (s) i.e.:<br>
                <b>import "fmt"</b><br>
                Or:<br>
                <code>import (
fmt"
"unicode/utf8"
"strings"
"strconv"
)</code>
                Go will not allow code pollution use what you import or don't import it at all</p>    
    <hr>
    </article>
</section>
<section class="main-section" id="inst">
    <header>Installation</header><hr>
    <article><p>
            Set variables:<br>
            <b>GOROOT</b> if go itself is installed somewhere else than default<br>
            <b>GOPATH</b> pointing to Go sources and workdirs WORKSPACE<br>
            <b>GOBIN</b> pointing to bin directory inside Go Workspace<br>
            <b>go help + command</b> = Documentation<br>
            Environment variables:<br>
            <code>export PATH=$PATH:/sbin
echo $PATH</code>
            Set Go binary PATH system-wide in /etc/profile<br>
            <code>export PATH=$PATH:/usr/local/go/bin</code>
            User environment PATH declaration in ~/.profile<br>
            For our workspace to work with Go and the rest of the system programs whereas it remains private as our own workspace<br>
            <code>export GOPATH=$HOME/workspaces/gocode
export PATH=$HOME/workspaces/gocode/bin:$PATH</code>
            The last $PATH is for go can know where are the other programs on the system<br>
            <b>go help environment</b> <== for a comprehensive help about environment variables in GO
    </p><hr>
    </article>
</section>
<section class="main-section" id="basics">
    <header>Basic Commands</header><hr>
    <article><p>
            <p><b>go run</b> needs a file name, eg, go run main.go<br>
                <b>go build</b> for an executable: builds the file, reports errors, if any. If there are no errors, it puts an executable into the current folder.<br>
                for a package: builds the file, reports errors, if any. And throws away binary.<br>
                <b>go install</b> for an executable: compiles the program (builds it), names the executable the folder name holding the code, puts the executable in workspace / bin.<br>
                <b>$GOPATH/bin</b> for a package: compiles the package (builds it), puts the executable in workspace / pkg<br>
                <b>$GOPATH/pkg</b> makes it an archive file<br>
                <b>go clean</b> cleans folders (Add more information)</p>
                <h3>Go FMT Verbs and Escape characters</h3>
                <p>Format verbs examples:<br>
                Formatting in HEX CAPS with 0x prefix:<br>
                <b>%#x</b><br><b>
                %#X</b><br>
                Formatting in DECIMALS:<br><b>
                %d</b><br>
                Formatting in BINARY:<br><b>
                %b</b><br>
                Formatting in text encapsulated in '…' with a safe return to a new line:<br><b>
                %q</b>
                Escape characters:<br>
                Adds a tabulation:<br><b>
                \t</b><br>
                Adds a return to a new line afterwards:<br><b>
                \n</b>
                </p>
    </p><hr>
    </article>
</section>
<section class="main-section" id="ssh">
    <header>Installing over SSH</header><hr>
    <article>
            <p><code>ssh root@debsrv05s 'cd /usr/local && wget \
https://storage.googleapis.com/golang/go1.8.1.linux-amd64.tar.gz && \
tar -xzvf go1.8.1.linux-amd64.tar.gz && go version && rm -f go1.8.1.linux-amd64.tar.gz'</code>
Then the environment variables can be applied remotely with the content of variables or of a file to happen to .profile
Obviously the command above needs to be modified with the proper server name and the current Go-Lang version.</p>    
    <hr>
    </article>
</section>
<section class="main-section" id="basic">
        <header>Basic Concepts</header><hr>
        <article>
                <h1>Base formating</h1>
                <p>Our very first package. Folders organization:<br>
                <code><b>~/Workspaces/gocode/src/github/go-lang-training</b>$ ls -lR first_package/
first_package/:
main
stringutil
first_package/main:
main.go
first_package/stringutil:
name.go
reverse.go
reverseTwo.go</code></p>	
                <p>But before a little formating with <b>fmt</b></p>
<code>package main
                
import "fmt"
                
func main() {
            fmt.Printf("%d \t %b \t %#x \n", 2048, 2048, 2048)
            // Decimal d, Binary b, Hexadecimal x
            // Print some numbers base formated \t is new line
            }</code></p>
                <p>stringutil/main.go</p>
                <code>package main

import (
        "fmt"
        "github.com/t0m-a/golangex/firstPackage/<b>stringutil</b>"
        )
                
        func main() {
                    fmt.Println(<b>stringutil.<u>Reverse</u></b>("!og, og, oG !olleH"))
                    fmt.Println(<b>stringutil.<u>MyName</u>, stringutil.<u>MyPlace</u></b>)
                    }
                
                    // Calling to functions we packaged in first_package/stringutil/name.go
                    // reverse.go
                    // function.Variable</code></p>	
                <p>name.go</p>
                <code>
                package stringutil
                
                // MyName declared as a variable and assigning Tom as its value
                var MyName = "Tom"
                
                // MyPlace declared with assigned value of 127.0.0.1
                var MyPlace = "@127.0.0.1"
                </code>
                <p>reverse.go</p>
                <code>// Package stringutil we are calling for a package of our own containing functions for working with strings.
package stringutil
             
// Reverse returns its argument declared with (s string) processed by
// the function reverseTwo
func Reverse(s string) string {
return reverseTwo(s)
}</code>
                <p>reverseTwo.go</p><code>
package stringutil
                
func reverseTwo(s string) string {
                                    r := []rune(s)
                                    for i, j := 0, len(r)-1; i < len(r)/2; i, j = i+1, j-1 {
                                    r[i], r[j] = r[j], r[i]
                                 }
                                return string(r)
                                }</code>
        <hr>
        </article>
</section>
<section class="main-section" id="rem">
        <header>Remainder</header><hr>
        <article><p>remainder symbol is % in a variable value</p>
                <code>package main
                
                import "fmt"
                
                <b>//remainder symbol is % in a variable value</b>
                
                func main() {
                
                    // 4 divided by 2 makes 2 and remains 0
                    quotient := 4 / 2
                    fmt.Printf("%d \t", quotient)
                    fmt.Println(&quotient)
                
                    remainder := 4 % 2
                    fmt.Printf("%d \t", remainder)
                    fmt.Println(&remainder)
                
                    // 5 contains two times 2 and it remains 1
                    quotient2 := 5 / 2
                    fmt.Printf("%d \t", quotient2)
                    fmt.Println(&quotient2)
                
                    remainder2 := 5 % 2
                    fmt.Printf("%d \t", remainder2)
                    fmt.Println(&remainder2)
                
                    // How many times is there the number 3 in 4999
                    var quotient3 float32
                    quotient3 = 4999 / 3
                    fmt.Printf("%f \t", quotient3) // %f is format verb for floating numbers
                    fmt.Println(&quotient3)
                    // Answer is 1666 times
                    // How many remains
                    var remainder3 float32
                    remainder3 = 4999 % 3
                    fmt.Printf("%f \t", remainder3)
                    fmt.Println(&remainder3)
                    // and 1 time 3 remains that cannot be contained in the quotient
                    // It's logical, mathematical would give 1666,333333 etc...
                    <b>// Remainder are usefull to check if a number is odd or even (impair ou pair)</b>
                }</code>
        </p><hr>
        </article>
</section>
<section class="main-section" id="loop">
        <header>Loop and Print</header><hr>
        <article><p>
                <code>package main
                        
                        import "fmt"
                        
                        func main() {
                            for i := 0; i < 200; i++ {
                                fmt.Printf("%d \t %b \t %x %q \n", i, i, i, i)
                            }
                        }</code>
        </p><hr>
        </article>
</section>
<section class="main-section" id="var">
        <header>Variables and Constants</header><hr>
        <article>
                <h1>Declare and initialize variables</h1>
                <h1>Variables</h1>
                <p>Mémo de cours et exercice</p>
                <code>Dans le dossier Declare_and_Init se trouve un exercice commenté expliquant et mettant en pratique 
                la déclaration, l'assignation et l'affichage de variables sur la sortie standard.
                La déclaration et l'assignation de variables peut être multiple.
                Une variable à zero ou nul est une variable déclarée mais non assignée.
                
                2 façon de déclarer sont à préférer:
                
                -	shorthand /!\ UTILISABLE QUE DANS UNE FUNC 
                -	var
                
                i.e.:
                
                // DECLARATION de variables selon la méthode shorthand qui N'EST UTILISABLE QUE A L'INTERIEUR D'UNE FUNC
                
                    var a int     // var déclarée soit nomée a, et qui a pour type int (nombre intègre)
                
                    var b string  // var déclarée (soit nomée) b, et qui a pour type string (chaîne de catactères)
                
                    var c float64 // de type nombre décimal DOUBLE-PRECISION FLOATING-POINT FORMAT (FLOAT64) SÉPARÉ PAR UN POINT 
                    (et non pas par une virgule)
                
                    var d bool    // ... de type bolean true or false aKa yes or no ou plutôt 1 ou 0 ;)
                
                    // DECLARATION et ASSIGNATION de variables MULTIPLES
                
                    var e, f string = "je suis le contenu de la var e", "je suis le contenu de la var f"
                
                    // /!\ ASSIGNATION /!\ de la valeur à une variable précédement déclarée (nomée) et typée
                    a = 7
                    b = "couscous"
                    c = 3.1415
                    d = true	
                </code>
                <p>declare_and_initialize/main.go</p>
                <code>package main
                
                import "fmt"
                
                func main() {
                    // DECLARATION de variables selon la méthode shorthand qui N'EST UTILISABLE QUE A L'INTERIEUR D'UNE FUNC
                    var a int     // var déclarée soit nomée a, et qui a pour type int (nombre intègre)
                    var b string  // var déclarée (soit nomée) b, et qui a pour type string (chaîne de catactères)
                    var c float64 // ... de type nombre décimal DOUBLE-PRECISION FLOATING-POINT FORMAT (FLOAT64) SÉPARÉ PAR UN POINT
                    (et non pas par une virgule)
                    var d bool    // ... de type bolean true or false aKa yes or no ou plutôt 1 ou 0 ;)
                
                    // DECLARATION et ASSIGNATION de variables MULTIPLES
                
                    var e, f string = "je suis le contenu de la var e", "je suis le contenu de la var f"
                
                    // /!\ ASSIGNATION /!\ de la valeur à une variable précédement déclarée (nomée) et typée
                    a = 7
                    b = "couscous"
                    c = 3.1415
                    d = true
                
                    // AFFICHE LE TYPE déclaré de la variables avec un retour chariot, virgule le nom de la variable 
                    // dont on affiche le type
                    // %T permetant d'afficher ou représenter le Type T de la variable
                    fmt.Println("Affichons le type T de nos variables :")
                    fmt.Printf("%T \n", a)
                    fmt.Printf("%T \n", b)
                    fmt.Printf("%T \n", c)
                    fmt.Printf("%T \n", d)
                    fmt.Printf("%T \n", e)
                    fmt.Printf("%T \n", f)
                
                    // AFFICHE LA VALEUR assignée de la variables avec un retour chariot, virgule le nom de la variable 
                    // dont on affiche la valeur
                    // %v permetant d'afficher ou représenter la Valeur V de la variable dans son format par défaut
                    fmt.Println("Affichons la valeur V de nos variables :")
                    fmt.Printf("%v \n", a)
                    fmt.Printf("%v \n", b)
                    fmt.Printf("%v \n", c)
                    fmt.Printf("%v \n", d)
                    fmt.Printf("%v \n", e)
                    fmt.Printf("%v \n", f)
                
                    // Une autre façon d'afficher type et valeur mais sur la même ligne de la STDOUT 
                    // avec deux ou trois \t tabulation pour l'alignement
                    // et un \n pour le retour à la ligne
                    fmt.Println("Affichons le type T et la valeur V de chacune de nos variables sur la même ligne pour chacune :")
                    fmt.Printf("%T \t \t \t %v \n", a, a)
                    fmt.Printf("%T \t \t \t %v \n", b, b)
                    fmt.Printf("%T \t \t %v \n", c, c)
                    fmt.Printf("%T \t \t \t %v \n", d, d)
                    fmt.Printf("%T \t \t \t %v \n", e, e)
                    fmt.Printf("%T \t \t \t %v \n", f, f)
                }	
                </code>
                <h1>Constants</h1>
                <code>
                package main
                
                import "fmt"
                
                // Constants aKa CONST is a SIMPLE UNCHANGING (in the program) VALUE
                const p string = "granit"
                
                const r = 4096.556 // work as const r string = would work. As much as const r = "4096 or mémé or 4678,0" would work.
                // The comma expressed decimal number needs double quotes around it otherwise use a dot const r = "3,14" 
                // VERSUS const r = 3.14
                // It can be named or defined as: const conR = or const conDistanceTo = ... 
                // etc... conXXX enabling to differenciate it for a variable
                
                // Declaring multiple constants at once ex:
                const (
                
                    // All these three above aligned with tabulation so the code is cleaner to read, 
                    // BTW PREFERE COMMENTING RIGHT ABOVE WHAT YOU ARE COMMENTING with NO EXTRA LINE
                    pi       = "3,1415"
                    pi2      = 3.1415
                    language = "Go lang! GO !"
                
                    // L : where we see how to style our code according to lint and elegant GO writting. 
                    // This comment MUST start with the name of the constant (work with anything you need to export)
                    // It seems like a way to force good commenting habits for all exports outside the scope 
                    // so that the whole program can be easily maintainable and readable
                    L = "see what Go says when using a Capital Letter as the first letter used when declaring a constant"
                
                    // Now we are done with Export or non export let's have a look at /!\ iota /!\
                    whatsaniota       = iota // 4
                    thisisaniota      = iota // 5
                    incaseyoumissedit = iota // 6 because first const pi is 0, pi2 is 1 and so on
                )
                
                const (
                    x = iota // 0 because IOTA RESETS when we use a new block of declared constants
                    y = iota // 1 and so on
                
                )
                
                const (
                    // Now we are using a BLANK IDENTIFIER to ommit the IOTA 0
                    _ = iota      // which value is 0 which we ignore with the BLANK IDENTIFIER
                    g = iota * 10 // 1*10
                    h = iota * 10 // 2*10 and so on
                    i = g * h     // AWESOME !!! We can multiply constants by themselves
                    k = i * i
                )
                
                func main() {
                
                    const q = 42
                    const s = "3,1415"
                    const t bool = false
                
                    fmt.Println("p - ", p)
                    fmt.Println("q - ", q)
                    fmt.Println("r - ", r)
                    fmt.Println("s - ", s)
                    fmt.Println("t - ", t)
                    // Aligned with tab so it's cleaner to read on STDOUT
                    fmt.Println("Pi the \"european way\" \t - ", pi)
                    fmt.Println("Pi the \"US\" way \t - ", pi2)
                    fmt.Println("Language is - \t \t", language)
                    fmt.Println("L - ", L)
                    fmt.Println("whatsaniota - ", whatsaniota)
                    fmt.Println("thisisaniota - ", thisisaniota)
                    fmt.Println("incaseyoumissedit - ", incaseyoumissedit)
                    fmt.Println("x - ", x)
                    fmt.Println("y - ", y)
                    fmt.Println("g - ", g)
                    fmt.Println("h - ", h)
                    fmt.Println("i - ", i)
                    fmt.Println("k - ", k)
                }</code>
                <h1>Bitwise operations</h1>
                <code>                package main
                
                import "fmt"
                
                const (
                    _  = iota             // 0 ignored
                    kb = 1 << (iota * 10) // 1 is shifted << by iota times ten (1 * 10)
                    mb = 1 << (iota * 10) // 1 << (2 * 10) The bit 1 is shifted by 2 * 10 positions 
                                          // on the 2 to the power of n table of calcul
                    gb = 1 << (iota * 10)
                    tb = 1 << (iota * 10)
                )
                
                func main() {
                
                    fmt.Println("binary\t\t\t\t\t\t\tdecimal")
                    fmt.Printf("%b\t\t\t\t\t\t%d\n", kb, kb)
                    fmt.Printf("%b\t\t\t\t\t%d\n", mb, mb)
                    fmt.Printf("%b\t\t\t\t%d\n", gb, gb)
                    fmt.Printf("%b\t\t%d\n", tb, tb)
                
                }
                </code></p>    
        <hr>
        </article>
</section>
<section class="main-section" id="scope">
        <header>Scopes and Wrappers</header><hr>
        <article><p>
                <code>package main
                        
                        import "fmt"
                        
                        /* wrapper will enable us to return a function "as a value", 
                        the second func is currently an anonymous func and will be assigned (named) later on.
                        /!\ x= 0 is an OUTER SCOPE level assigned variable /!\ it will be remembered in the whole block scope 
                        contained in between the bracie { from line 8 to the closing } on line 14.
                        We could have use this var x in many other func as long as these func 
                        would have been enclosed in the BLOCK starting on the end of LINE 10.
                        /!\ From the opening bracie on LINE 13 we have our INNER SCOPE /!\
                        */
                        
                        func wrapper() func() int {
                            x := 0
                            return func() int {
                                x++
                                return x
                            }
                        }
                        
                        func main() {
                            increment := wrapper()   // We are assigning the anonymous func its value or name 
                                                     // which is increment CALLED EXPRESSING A FUNCTION aKa func expression
                            fmt.Println(increment()) // We are calling to the now assigned func increment. 
                                                     // As increment is a func it gets() right after it, 
                                                     // cause it has to execute stuff (what's on line 6 to 8)
                            fmt.Println(increment())
                        
                        }</code>
        </p><hr>
        </article>
</section>
<section class="main-section" id="mem">
        <header>Memory Addresses</header><hr>
        <article><p>
                <h1>README.md - Notes from courses</h1>
                <h3>(also contained in coding exercises in the subdirs)</h3>
                <h1>Referencing a memory pointer, dereferencing and reassigning variables</h1>
                <p>In go, <b>&</b> indicate memory address. &a means the memory address where the value of var a is stored.<br>
                /!\ VAR TYPE /!\ POINTER TO AN INT *int which means we point to the memaddress where the VALUE of b is stored.<br>
                <code>a := 43
                var bee *int = &a</code>
                <code>If we declare bee as = &a - bee will be automatically be inferred from context as of type *int (pointer to an int) *int -- the * is part of the type -- bee is of type *int
                
                Here, we are REFERENCING a VALUE (making a pointer to its memaddress)
                
                "*" Is always an operator * here means "pointer to" (an int)
                
                The above code makes bee a pointer to the memory address where an int is stored and bee is of type "int pointer"
                
                bee is of type "pointer to an int" which has for VALUE the memory address of where the value of var a is stored
                
                while *bee is DEREFERENCING the variable bee, meaning here we get the ACTUAL CONTENT of the value of bee stored in the memory</code>
                Here the * means dereferencing which gives us the actual content in a pointer memory address.<br>
                In other words: to see the value in that memory address, add a * in front of b : this is known as dereferencing,<br>
                the * is an operator in this case.</p>
                <p>REASSINGING the value of a variable:<br>
                <code>*b = 42 // *b means: change the value of b to whatever you need, here it's 42</code>
                From now on as we have reassigned the value of *b (star b, it's important)<br>
                *b is equal to the reassigned value 42 AS MUCH AS TO THE VALUE OF VAR a.<br>
                as b is equal to the memaddress of a ==> &a, and dereferenced b or *b is equal to the value of a.<br>
                So from now on the VALUE of var a will be the reassigned value of our dereferenced b ==> *b<br>
                <code>fmt.Println(a) // Will return 42 as THE NEWLY ASSIGNED VALUE of the var a</code></p>
                <h1>Courses input on reassigning a value to a memory address:</h1>
                <code>-	this is useful
                -	we can pass a memory address instead of a bunch of values, we can pass a reference
                -	and then we can still change the value of whatever is stored at that memory address
                -	this makes our programs more performant
                -	we don't have to pass around large amounts of data
                -	we only have to pass around addresses
                -	everything is PASS BY VALUE in go, btw
                -	when we pass a memory address, we are passing a value</code>
                <code>/*  Referencing a memmory pointer, dereferencing and reassigning
                    while having fun multiplying vars with each other, formating the results and making functions
                    Overkill func and vars just for example and exercise NEVER CODE THIS UGLY WAY
                    This is kind of a COURSES MEMO
                */
                
                import "fmt"
                
                // Variables which need to be used file scope wide must be outside any function block, 
                // preferably at the begining if already known at that point, to ease reading
                // If var was captial A it would have been exported: useable package wide
                
                var a = 3 // DECLARE+ASSIGN: declared var a of type int with assigned value of 300
                var b = 4
                var c *int = &a // /!\ REFERENCING a variable POINTER. &a equals *c (line 19,20)
                                // THIS IS FOR EXAMPLE ONLY
                var d *int = &b // Go prefer var d = &b and will infer type is of POINTER TO AN INT 
                                // because it reads &something, it infers from right-hand side
                
                // Any secondary function used in main must be declared prior to it->file scope, must respect anorder: 
                // First known (declared) and then useable
                func showofa() {
                
                    fmt.Println(&a, "\t", a)
                    fmt.Println(*c) // /!\ DEREFERENCING a pointer to an int, getting its ACTUAL VALUE for var a (3)
                }
                
                func showofb() {
                
                    fmt.Println(&b, "\t", b)
                    fmt.Println(*d)
                }
                
                func main() {
                
                    var result int
                    result = a * b
                
                    showofa()
                    showofb()
                
                    fmt.Println(result, "\t \t", &result)
                
                    *c = 2 // This means REASSIGNING a value of 2 to the DEREFERENCED var a
                    // hence &a = c and *c = actual value of a
                
                    var newresult int
                    newresult = a * b
                    fmt.Println(a)
                    fmt.Println(newresult, "\t \t", &newresult)
                
                    /* 	More explanation needed? See the courses notes in
                           ../reference_dereference_reassign/main.go - tom
                    */
                
                }                </code>  
        </p>
        </article>
</section>
<footer id="footer">&copy; 2019 All Rights Reserved Thomas Simon -
        <a href="https://github.com/t0m-a" target="_blank" title="t0m-a on GitHub">GitHub</a> - 
        <a href="https://hub.docker.com/u/simonthomas/" target="_blank" title="Thomas Simon repositories on Docker Hub">Docker Hub</a> - 
        <a href="https://www.facebook.com/tsim0n" target="_blank" title="Thomas Simon on Facebook">Facebook<a> - 
        <a href="https://www.linkedin.com/in/thomas-simon-bolivie/?locale=en_US" target="_blank" title="Professional Profile of Thomas Simon on LinkedIn">LinkedIn</a> - 
        <a href="https://twitter.com/7ohms" target="_blank" title="Twitter, where I talk the most">Twitter</a>
 </footer>
</main>
</body>
</html>